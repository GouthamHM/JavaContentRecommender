{"content": "However, the main Java runtime does not know about the Distance class. The name of the class to execute is a runtime value. Reflection allows a Java program to work with classes even though the classes are not known when the program was written.\nLet's explore what the invokeMain method is doing.\nThe first statement at line 9 is an example of dynamic class loading. The forName() method will load a Java class and return an instance of java.lang.Class that results from loading the class. In this case, we are loading the class \"Distance\" from the default package. We store the class object in the local variable distanceClass; its type is Class<?>.\nThe second statement at line 10 simply creates a String array with the four command line arguments we wish to pass to the main method of the Distance class.\nThe third statement at line 11 performs a reflection operation on the Distance class. The getMethod() method is defined for the Class class. It takes a variable number of parameters: the method name is the first parameter and the remaining parameters are the types of each of main's parameters. The method name is trivial: we want to invoke the main method, so we pass in the name \"main\". We then add a Class variable for each of the method parameters. main accepts one parameter (String[] args) so we add a single Class element representing the String[]. The getMethod method has a return type of java.lang.reflect.Method; we store the result in a local variable named mainMethod.\nFinally, we invoke the method by calling the invoke() method of the Method instance. This method's first parameter is the instance to invoke on, and the remaining parameters are for the invokee's parameters. Since we are invoking a static method and not an instance method, we pass null as the instance argument. Since we only have a single parameter we pass it as the second argument. However, we must cast the parameter to Object to indicate that the array is the parameter, and not that the parameters are in the array. See varargs for more details on this.\n", "stemmed": "howev , main java runtim know distanc class . the name class execut runtim valu . reflect allow java program work class even though class known program written . let 's explor invokemain method . the first statement line 9 exampl dynam class load . the fornam ( ) method load java class return instanc java.lang.class result load class . In case , load class `` distanc '' default packag . We store class object local variabl distanceclass ; type class < ? > . the second statement line 10 simpli creat string array four command line argument wish pass main method distanc class . the third statement line 11 perform reflect oper distanc class . the getmethod ( ) method defin class class . It take variabl number paramet : method name first paramet remain paramet type main 's paramet . the method name trivial : want invok main method , pass name `` main '' . We add class variabl method paramet . main accept one paramet ( string [ ] arg ) add singl class element repres string [ ] . the getmethod method return type java.lang.reflect.method ; store result local variabl name mainmethod . final , invok method call invok ( ) method method instanc . thi method 's first paramet instanc invok , remain paramet invoke 's paramet . sinc invok static method instanc method , pass null instanc argument . sinc singl paramet pass second argument . howev , must cast paramet object indic array paramet , paramet array . see vararg detail .", "link": "https://en.wikibooks.org/wiki/Java_Programming/Reflection/Overview"}